{
    "docs": [
        {
            "location": "/", 
            "text": "Characteristic Attribute Organization System (CAOS)\n\n\nThis package provides an interface to use the CAOS algorithm for sequence classification.\n\n\nIn an ideal world, a full phylogenetic analysis would be done on every new sequence found. However, this is often a time-consuming and computer-intensive task. The Characteristic Attribute Organization System (CAOS) is an algorithm to discover descriptive information about \na priori\n organized discretized data (\ne.g.\n, from a phylogenetic analysis). Derived from some of the fundamental tenets from evolutionary biology, rule sets can be generated from data sets that can be used for effecicient and effective classification of novel data elements. It's important to emphasize that CAOS is NOT a tree analysis, instead it is a classification scheme based on a phylogenetic analysis. Based on information (rules) discovered from the phylogenetic analysis that unambiguously distinguish between each node on a tree, CAOS is able to classify novel sequences. Studies have indicated that CAOS-based classification has over a 95% accuracy rate of classification, as determined by where sequences would be classified if a full phylogenetic analysis were to be done using the novel and known sequences.\n\n\nCAOS.jl is an implementation of the CAOS approach designed to approximate a parsimony-based tree analysis. This tool computes diagnostic character states from phylogenetic trees and uses them for classification of new molecular sequences.\n\n\n\n\nCAOS Publications\n\n\nSarkar IN, Thornton JW, Planet PJ, Figurski DH, Schierwater B, and DeSalle R. \nAn Autotmated Phylogenetic Key for Classifying Homoboxes.\n Molecular Genetics and Evolution (2002) 24: 388-399.    \n  \n\n\nSarkar IN, Planet PJ, and DeSalle R. \ncaos software for use in character\u2010based DNA barcoding\n. Molecular Ecology Resources (2008) 8, 1256-1259.    \n\n\n\n\n\n\nWorkflow\n\n\n\n\nFirst run the \ngenerate_caos_rules\n function on your tree in the required NEXUS format. This will create the necessary CAOS rules and files to use for classification.\n\n\nOnce you have generated your CAOS rules, you can load them with the function \nload_tree\n.\n\n\nLastly run the \nclassify_new_sequence\n function on the sequence you wish to classify.\n\n\n\n\n\n\nNEXUS File Format\n\n\nIn order for the parser to correctly extract all relevant information from your phylogeneitc tree, your NEXUS file must be in the exact format described below (most NEXUS files will already be in this format, but if you are having issues with your file being read properly, here is how to format it):\n\n\n\n\nThe tree must in Newick format\n\n\nThe tree must be on a line with the words \"TREE\" and \"=\"\n\n\nThe character labels (names associated with each sequence of characters) should be directly after a line with the word \"MATRIX\" (this should be the only time the word \"MATRIX\" appears in the file)\n\n\nEach character label should be its own line, with the name followed by a number of space, and then the character sequence\n\n\nAfter your last character label, the following line should contain only a \";\"\n\n\nTaxa labels (taxa numbers for the position in the newick formatted tree associated with each character sequence name) should appear directly after a line containing the word \"TRANSLATE\" (this should be the only occurrence of that word in the file)\n\n\nEach taxa label should be its own line, with the taxa number followed by the character sequence name (at least one space in between the two)\n\n\nThe line with the last taxa label should end with a \";\"\n\n\n\n\n\n\nExamples\n\n\nTwo example NEXUS files are provided in the \ntest/data\n folder : \nS10593.nex\n and \nE1E2L1.nex\n\n\nAn example sequence file is provided in the \ntest/data\n folder : \nExample_Sequence.txt\n\n\n\n\nFunctions\n\n\ngenerate_caos_rules(\ntest/data/S10593.nex\n, \ntest/data\n)\n\n\n\n\n\nThis will generate your CAOS rules for the tree in the \nS10593.nex\n NEXUS file and place all output files from rule generation in the \ntest/data\n directory.\n\n\ntree, character_labels, taxa_labels = load_tree(\ntest/data\n)\n\n\n\n\n\nThis will load the internal representation of the tree and CAOS rules from the files output during rule generation in the \ntest/data\n directory.\n\n\nclassification\n = \nclassify_new_sequence\n(\ntree\n, \ncharacter_labels\n, \ntaxa_labels\n, \ntest/data/Example_Sequence.txt\n, \ntest/data\n)\n\n\n\n\n\nThis will return the classification result, either a string with the classification label or a Node object (under classifiction).", 
            "title": "Home"
        }, 
        {
            "location": "/#characteristic-attribute-organization-system-caos", 
            "text": "This package provides an interface to use the CAOS algorithm for sequence classification.  In an ideal world, a full phylogenetic analysis would be done on every new sequence found. However, this is often a time-consuming and computer-intensive task. The Characteristic Attribute Organization System (CAOS) is an algorithm to discover descriptive information about  a priori  organized discretized data ( e.g. , from a phylogenetic analysis). Derived from some of the fundamental tenets from evolutionary biology, rule sets can be generated from data sets that can be used for effecicient and effective classification of novel data elements. It's important to emphasize that CAOS is NOT a tree analysis, instead it is a classification scheme based on a phylogenetic analysis. Based on information (rules) discovered from the phylogenetic analysis that unambiguously distinguish between each node on a tree, CAOS is able to classify novel sequences. Studies have indicated that CAOS-based classification has over a 95% accuracy rate of classification, as determined by where sequences would be classified if a full phylogenetic analysis were to be done using the novel and known sequences.  CAOS.jl is an implementation of the CAOS approach designed to approximate a parsimony-based tree analysis. This tool computes diagnostic character states from phylogenetic trees and uses them for classification of new molecular sequences.", 
            "title": "Characteristic Attribute Organization System (CAOS)"
        }, 
        {
            "location": "/#caos-publications", 
            "text": "Sarkar IN, Thornton JW, Planet PJ, Figurski DH, Schierwater B, and DeSalle R.  An Autotmated Phylogenetic Key for Classifying Homoboxes.  Molecular Genetics and Evolution (2002) 24: 388-399.         Sarkar IN, Planet PJ, and DeSalle R.  caos software for use in character\u2010based DNA barcoding . Molecular Ecology Resources (2008) 8, 1256-1259.", 
            "title": "CAOS Publications"
        }, 
        {
            "location": "/#workflow", 
            "text": "First run the  generate_caos_rules  function on your tree in the required NEXUS format. This will create the necessary CAOS rules and files to use for classification.  Once you have generated your CAOS rules, you can load them with the function  load_tree .  Lastly run the  classify_new_sequence  function on the sequence you wish to classify.", 
            "title": "Workflow"
        }, 
        {
            "location": "/#nexus-file-format", 
            "text": "In order for the parser to correctly extract all relevant information from your phylogeneitc tree, your NEXUS file must be in the exact format described below (most NEXUS files will already be in this format, but if you are having issues with your file being read properly, here is how to format it):   The tree must in Newick format  The tree must be on a line with the words \"TREE\" and \"=\"  The character labels (names associated with each sequence of characters) should be directly after a line with the word \"MATRIX\" (this should be the only time the word \"MATRIX\" appears in the file)  Each character label should be its own line, with the name followed by a number of space, and then the character sequence  After your last character label, the following line should contain only a \";\"  Taxa labels (taxa numbers for the position in the newick formatted tree associated with each character sequence name) should appear directly after a line containing the word \"TRANSLATE\" (this should be the only occurrence of that word in the file)  Each taxa label should be its own line, with the taxa number followed by the character sequence name (at least one space in between the two)  The line with the last taxa label should end with a \";\"", 
            "title": "NEXUS File Format"
        }, 
        {
            "location": "/#examples", 
            "text": "Two example NEXUS files are provided in the  test/data  folder :  S10593.nex  and  E1E2L1.nex  An example sequence file is provided in the  test/data  folder :  Example_Sequence.txt", 
            "title": "Examples"
        }, 
        {
            "location": "/#functions", 
            "text": "generate_caos_rules( test/data/S10593.nex ,  test/data )  This will generate your CAOS rules for the tree in the  S10593.nex  NEXUS file and place all output files from rule generation in the  test/data  directory.  tree, character_labels, taxa_labels = load_tree( test/data )  This will load the internal representation of the tree and CAOS rules from the files output during rule generation in the  test/data  directory.  classification  =  classify_new_sequence ( tree ,  character_labels ,  taxa_labels ,  test/data/Example_Sequence.txt ,  test/data )  This will return the classification result, either a string with the classification label or a Node object (under classifiction).", 
            "title": "Functions"
        }, 
        {
            "location": "/documentation/", 
            "text": "Import\n\n\nusing CAOS\n\n\n\n\n\n\n\nIndex\n\n\n\n\nCAOS.Node\n\n\nCAOS.Rule\n\n\nCAOS.CA_matches\n\n\nCAOS.CV_classification\n\n\nCAOS.add_blanks\n\n\nCAOS.add_blanks_to_back\n\n\nCAOS.add_blanks_to_front\n\n\nCAOS.add_nodes!\n\n\nCAOS.check_CV_classification\n\n\nCAOS.classify_all_CV\n\n\nCAOS.classify_new_sequence\n\n\nCAOS.classify_sequence\n\n\nCAOS.convert_to_struct\n\n\nCAOS.downsample_taxa\n\n\nCAOS.find_sequence\n\n\nCAOS.generate_caos_rules\n\n\nCAOS.get_adjusted_start\n\n\nCAOS.get_all_neighbors\n\n\nCAOS.get_best_hit\n\n\nCAOS.get_cPu_and_cPr\n\n\nCAOS.get_descendents\n\n\nCAOS.get_duplicate_labels\n\n\nCAOS.get_first_taxa_from_tree\n\n\nCAOS.get_group_combos\n\n\nCAOS.get_group_taxa_at_node\n\n\nCAOS.get_max_depth\n\n\nCAOS.get_neighbors\n\n\nCAOS.get_next_hit\n\n\nCAOS.get_nodes\n\n\nCAOS.get_sPu_and_sPr\n\n\nCAOS.load_tree\n\n\nCAOS.parse_tree\n\n\nCAOS.remove_blanks\n\n\nCAOS.remove_from_tree!\n\n\n\n\n\n\nFunctions\n\n\n#\n\n\nCAOS.classify_new_sequence\n \n \nMethod\n.\n\n\nclassify_new_sequence\n(\ntree\n::\nNode\n,\n \ncharacter_labels\n::\nDict\n{\nString,String\n}\n,\n \ntaxa_labels\n::\nDict\n{\nString,String\n}\n,\n\n\nsequence_file_path\n::\nString\n,\n \noutput_directory\n::\nString\n \n;\n \nall_CA_weights\n::\nDict\n{\nInt64,\n\n\nDict{String,Int64\n}\n}\n=\nDict\n(\n1\n=\nDict\n(\nsPu\n=\n1\n,\nsPr\n=\n1\n,\ncPu\n=\n1\n,\ncPr\n=\n1\n)),\n \noccurrence_weighting\n::\nBool\n=\nfalse\n,\n\n\ntiebreaker\n::\nVector\n{\nDict{String,Int64\n}\n}\n=\n[\nDict\n{\nString\n,\nInt64\n}()\n]\n,\n \ncombo_classification\n::\nBool\n=\nfalse\n)\n\n\n\n\n\n\nTakes a tree (Node) and a sequence, and classifies the new sequence using the CAOS tree.\n\n\nArguments\n\n\n\n\ntree::Node\n: the tree represented as a Node.\n\n\ncharacter_labels::Dict{String,String}\n: a mapping of the character labels to the corresponding sequences.\n\n\ntaxa_labels::Dict{String,String}\n: a mapping of the taxa labels to the character labels.\n\n\nsequence_file_path::String\n: a file path to the sequence to classify.\n\n\noutput_directory::String\n: path to the output directory.\n\n\nall_CA_weights::Dict{Int64,Dict{String,Int64}}=Dict(1=\nDict(\"sPu\"=\n1,\"sPr\"=\n1,\"cPu\"=\n1,\"cPr\"=\n1))\n: CA weights to be used.\n\n\noccurrence_weighting::Bool=false\n: whether to use occurence weighting in classification.\n\n\ntiebreaker::Vector{Dict{String,Int64}}=[Dict{String,Int64}()]\n: tiebreaker to be used in classification.\n\n\ncombo_classification::Bool=false\n: whether to use a combo of Blast and CAOS for classification.\n\n\n\n\nsource\n\n\n#\n\n\nCAOS.find_sequence\n \n \nMethod\n.\n\n\nfind_sequence(tree::Node, taxa_label::String)\n\n\n\n\n\nTakes a tree (Node) and a taxa label and finds the subtree containing that sequence.\n\n\nArguments\n\n\n\n\ntree::Node\n: the tree represented as a Node.\n\n\ntaxa_label::String\n: taxa label.\n\n\n\n\nsource\n\n\n#\n\n\nCAOS.generate_caos_rules\n \n \nMethod\n.\n\n\ngenerate_caos_rules(tree_file_path::String, output_directory::String)\n\n\n\n\n\nTakes a Nexus file and generates all the CAOS rules for the tree.\n\n\nArguments\n\n\n\n\ntree_file_path::String\n: path to the Nexus file.\n\n\noutput_directory::String\n: path to the output directory.\n\n\n\n\nsource\n\n\n#\n\n\nCAOS.get_max_depth\n \n \nMethod\n.\n\n\nget_max_depth(tree::Node, depth::Int64)\n\n\n\n\n\nTakes a tree (Node) and gets the maximum depth.\n\n\nArguments\n\n\n\n\ntree::Node\n: the tree represented as a Node.\n\n\ndepth::Int64\n: current depth.\n\n\n\n\nsource\n\n\n#\n\n\nCAOS.get_nodes\n \n \nMethod\n.\n\n\nget_nodes\n(\ntree\n::\nString\n \n;\n \ntaxa_to_remove\n::\nUnion\n{\nArray{String,1\n}\n,\nBool\n}\n=\nfalse\n)\n\n\n\n\n\n\nTakes a tree in Newick format, returns an internal representation of the tree.\n\n\nArguments\n\n\n\n\ntree::String\n: the tree in Newick format.\n\n\ntaxa_to_remove::Union{Array{String,1},Bool}=false\n: the taxa that will be removed (if applicable).\n\n\n\n\nsource\n\n\n#\n\n\nCAOS.load_tree\n \n \nMethod\n.\n\n\nload_tree(directory::String)\n\n\n\n\n\nLoads a CAOS tree from file.\n\n\nArguments\n\n\n\n\ndirectory::String\n: path to directory where tree exists.\n\n\n\n\nsource\n\n\n#\n\n\nCAOS.parse_tree\n \n \nMethod\n.\n\n\nparse_tree\n(\nfile_path\n::\nString\n;\n \ntaxa_to_remove\n::\nUnion\n{\nArray{String,1\n}\n,\nBool\n}\n=\nfalse\n)\n\n\n\n\n\n\nTakes a Nexus file for a tree, returns an internal representation of that tree (and other relevant information).\n\n\nArguments\n\n\n\n\nfile_path::String\n: file path to the Nexus file.\n\n\ntaxa_to_remove::Union{Array{String,1},Bool}=false\n: the taxa that will be removed (if applicable).\n\n\n\n\nsource\n\n\n#\n\n\nCAOS.remove_blanks\n \n \nMethod\n.\n\n\nremove_blanks\n(\nchar_label_dict\n::\nDict\n{\nString,String\n}\n \n;\n \nchange_to_N\n::\nBool\n=\nfalse\n)\n\n\n\n\n\n\nChanges all blanks to N's in character sequences.\n\n\nArguments\n\n\n\n\nchar_label_dict::Dict{String,String}\n: character label mappings.\n\n\nchange_to_N::Bool=false\n: whether to change to N or just remove.\n\n\n\n\nsource\n\n\n#\n\n\nCAOS.remove_from_tree!\n \n \nMethod\n.\n\n\nremove_from_tree!(tree_tokens::Vector{String}, taxa_to_remove::Union{Array{String,1},Bool})\n\n\n\n\n\nTakes a tree in Newick format, removes a specific taxa from the tree.\n\n\nArguments\n\n\n\n\ntree_tokens::Vector{String}\n: the tree in Newick format, tokenized.\n\n\ntaxa_to_remove::Union{Array{String,1},Bool}\n: the taxa that will be removed.\n\n\n\n\nsource\n\n\n#\n\n\nCAOS.CA_matches\n \n \nMethod\n.\n\n\nCA_matches(sequence::String, CAs::Vector{Rule}, CA_weights::Dict{String,Int64}, occurrence_weighting::Bool)\n\n\n\n\n\nCounts the number of CA's matched by a sequence (only support for simple rules).\n\n\nArguments\n\n\n\n\nsequence::String\n: sequence to count matches.\n\n\nCAs::Vector{Rule}\n: list of all CA's.\n\n\nCA_weights::Dict{String,Int64}\n: weights to use for CA counts.\n\n\noccurrence_weighting::Bool\n: whether to use occurrence weighting during counting.\n\n\n\n\nsource\n\n\n#\n\n\nCAOS.CV_classification\n \n \nMethod\n.\n\n\nCV_classification\n(\ntaxa_label\n::\nString\n,\n \ncharacter_labels\n::\nDict\n{\nString,String\n}\n,\n\n\ngene\n::\nString\n,\n \npercent_test\n::\nString\n,\n \nall_CA_weights\n::\nDict\n{\nInt,Dict{String,Int64\n}\n}\n,\n\n\noccurrence_weighting\n::\nBool\n,\n \ntiebreaker\n::\nVector\n{\nDict{String,Int64\n}\n}\n;\n \ncombo_classification\n::\nBool\n=\nfalse\n)\n\n\n\n\n\n\nGets the classification for a LOOCV tree.\n\n\nArguments\n\n\n\n\ntaxa_label::String\n: taxa to classify.\n\n\ncharacter_labels::Dict{String,String}\n: a mapping of the character labels to the corresponding sequences.\n\n\ngene::String\n: gene which is being classified.\n\n\npercent_test::String\n: percent we are testing on.\n\n\nall_CA_weights::Dict{Int64,Dict{String,Int64}}\n: all sets of weights to use for CA counts.\n\n\noccurrence_weighting::Bool\n: whether to use occurrence weighting during counting.\n\n\ntiebreaker::Vector{Dict{String,Int64}}\n: tiebreaking procedures to use.\n\n\ncombo_classification::Bool=false\n: whether to use both Blast and CAOS for classification.\n\n\n\n\nsource\n\n\n#\n\n\nCAOS.add_blanks\n \n \nMethod\n.\n\n\nadd_blanks\n(\nquery_path\n::\nString\n,\n \ndb_path\n::\nString\n,\n \ncharacter_labels\n::\nDict\n{\nString,String\n}\n,\n\n\ncharacter_labels_no_gaps\n::\nDict\n{\nString,String\n}\n \n;\n \nreturn_blast\n::\nBool\n=\nfalse\n)\n\n\n\n\n\n\nAdds blanks to an input sequence given a database.\n\n\nArguments\n\n\n\n\nquery_path::String\n: path to the query file.\n\n\ndb_path::String\n: path to the blast database.\n\n\ncharacter_labels::Dict{String,String}\n: a mapping of the character labels to the corresponding sequences.\n\n\ncharacter_labels_no_gaps::Dict{String,String}\n: character labels with gaps removed from sequences.\n\n\nreturn_blast::Bool=false\n: whether to return blast results.\n\n\n\n\nsource\n\n\n#\n\n\nCAOS.add_blanks_to_back\n \n \nMethod\n.\n\n\nadd_blanks_to_back(subject::String, query::String, new_seq::String,\nsubj_len::Int64, query_len::Int64, subj_non_blanks::Int64,\nhitnames::Vector{String}, hit_idx::Int64, character_labels::Dict{String,String})\n\n\n\n\n\nAdds blanks to the back of a sequence from a blast match.\n\n\nArguments\n\n\n\n\nsubject::String\n: the subject the query is being matched to.\n\n\nquery::String\n: the query that is having blanks added to it.\n\n\nnew_seq::String\n: the new sequence (query with added blanks).\n\n\nsubj_len::Int64\n: length of the subject.\n\n\nquery_len::Int64\n: length of the query.\n\n\nsubj_non_blanks::Int64\n: number of non blanks in the subject.\n\n\nhitnames::Vector{String}\n: list of blast hits.\n\n\nhit_idx::Int64\n: index of the current blast hit.\n\n\ncharacter_labels::Dict{String,String}\n: a mapping of the character labels to the corresponding sequences.\n\n\n\n\nsource\n\n\n#\n\n\nCAOS.add_blanks_to_front\n \n \nMethod\n.\n\n\nadd_blanks_to_front(subject::String, query::String, new_seq::String,\nsubj_len::Int64, query_len::Int64, subj_non_blanks::Int64,\nhitnames::Vector{String}, hit_idx::Int64, character_labels::Dict{String,String})\n\n\n\n\n\nAdds blanks to the front of a sequence from a blast match.\n\n\nArguments\n\n\n\n\nsubject::String\n: the subject the query is being matched to.\n\n\nquery::String\n: the query that is having blanks added to it.\n\n\nnew_seq::String\n: the new sequence (query with added blanks).\n\n\nsubj_len::Int64\n: length of the subject.\n\n\nquery_len::Int64\n: length of the query.\n\n\nsubj_non_blanks::Int64\n: number of non blanks in the subject.\n\n\nhitnames::Vector{String}\n: list of blast hits.\n\n\nhit_idx::Int64\n: index of the current blast hit.\n\n\ncharacter_labels::Dict{String,String}\n: a mapping of the character labels to the corresponding sequences.\n\n\n\n\nsource\n\n\n#\n\n\nCAOS.add_nodes!\n \n \nMethod\n.\n\n\nadd_nodes\n!(\ntree\n::\nNode\n,\nsPu\n::\nArray\n{\nDict{String,Any\n}\n}\n,\nsPr\n::\nArray\n{\nDict{String,Any\n}\n}\n,\n\n\ncPu\n::\nArray\n{\nDict{String,Any\n}\n}\n,\ncPr\n::\nArray\n{\nDict{String,Any\n}\n}\n,\ntaxa_labels\n::\nDict\n{\nString,String\n}\n,\n\n\ncharacter_labels\n::\nDict\n{\nString,String\n}\n,\nnodes\n::\nArray\n{\nDict{String,Any\n}\n}\n,\nnode_num\n::\nInt64\n;\ncomplex\n::\nBool\n=\ntrue\n)\n\n\n\n\n\n\nTakes a tree (Node), adds all the CA's from the entire tree into the internal representation.\n\n\nArguments\n\n\n\n\ntree::Node\n: the tree represented as a Node.\n\n\nsPu::Array{Dict{String,Any}}\n: an array of simple pure rules.\n\n\nsPr::Array{Dict{String,Any}}\n: an array of simple private rules.\n\n\ncPu::Array{Dict{String,Any}}\n: an array of complex pure rules.\n\n\ncPr::Array{Dict{String,Any}}\n: an array of complex private rules.\n\n\ntaxa_labels::Dict{String,String}\n: a mapping of the taxa labels to the character labels.\n\n\ncharacter_labels::Dict{String,String}\n: a mapping of the character labels to the corresponding sequences.\n\n\nnodes::Array{Dict{String,Any}}\n: an array of nodes.\n\n\nnode_num::Int64\n: the current node number.\n\n\ncomplex::Bool=true\n: indicates whether complex rules should be calculated\n\n\n\n\nsource\n\n\n#\n\n\nCAOS.check_CV_classification\n \n \nMethod\n.\n\n\ncheck_CV_classification(taxa_label::String, character_labels::Dict{String,String},\ntaxa_labels::Dict{String,String}, classification::Any, gene::String)\n\n\n\n\n\nChecks if the classification from a LOOCV tree is correct.\n\n\nArguments\n\n\n\n\ntaxa_label::String\n: taxa to classify.\n\n\ncharacter_labels::Dict{String,String}\n: a mapping of the character labels to the corresponding sequences.\n\n\ntaxa_labels::Dict{String,String}\n: a mapping of the taxa labels to the character labels.\n\n\nclassification::Any\n: the classification to check.\n\n\ngene::String\n: gene which is being classified.\n\n\n\n\nsource\n\n\n#\n\n\nCAOS.classify_all_CV\n \n \nMethod\n.\n\n\nclassify_all_CV\n(\ncharacter_labels\n::\nDict\n{\nString,String\n}\n,\n \ntaxa_labels\n::\nDict\n{\nString,String\n}\n,\n\n\ngene\n::\nString\n,\n \npercent_test\n::\nString\n \n;\n \nblast_only\n::\nBool\n=\nfalse\n,\n\n\nall_CA_weights\n::\nDict\n{\nInt64,Dict{String,Int64\n}\n}\n=\nDict\n(\n1\n=\nDict\n(\nsPu\n=\n1\n,\nsPr\n=\n1\n,\ncPu\n=\n1\n,\ncPr\n=\n1\n)),\n\n\noccurrence_weighting\n::\nBool\n=\nfalse\n,\n \ntiebreaker\n::\nVector\n{\nDict{String,Int64\n}\n}\n=\n[\nDict\n{\nString\n,\nInt64\n}()\n]\n,\n\n\ndownsample\n::\nBool\n=\nfalse\n,\n \ncombo_classification\n::\nBool\n=\nfalse\n)\n\n\n\n\n\n\nClassifies all sequences using CAOS and LOOCV.\n\n\nArguments\n\n\n\n\ncharacter_labels::Dict{String,String}\n: a mapping of the character labels to the corresponding sequences.\n\n\ntaxa_labels::Dict{String,String}\n: a mapping of the taxa labels to the character labels.\n\n\ngene::String\n: gene which is being classified.\n\n\npercent_test::String\n: percent we are testing on.\n\n\nblast_only::Bool=false\n: whether we are only using Blast to classify.\n\n\nall_CA_weights::Dict{Int64,Dict{String,Int64}}=Dict(1=\nDict(\"sPu\"=\n1,\"sPr\"=\n1,\"cPu\"=\n1,\"cPr\"=\n1))\n: CA weights to be used.\n\n\noccurrence_weighting::Bool=false\n: whether to use occurence weighting in classification.\n\n\ntiebreaker::Vector{Dict{String,Int64}}=[Dict{String,Int64}()]\n: tiebreaker to be used in classification.\n\n\ndownsample::Bool=false\n: whether we are using downsampling.\n\n\ncombo_classification::Bool=false\n: whether to use a combo of Blast and CAOS for classification.\n\n\n\n\nsource\n\n\n#\n\n\nCAOS.classify_sequence\n \n \nMethod\n.\n\n\nclassify_sequence\n(\nsequence\n::\nString\n,\n \ntree\n::\nNode\n,\n \nCA_weights\n::\nDict\n{\nString,Int64\n}\n,\n\n\nall_CA_weights\n::\nDict\n{\nInt64,Dict{String,Int64\n}\n}\n,\n \noccurrence_weighting\n::\nBool\n,\n\n\ndepth\n::\nInt64\n,\n \ntiebreaker\n::\nVector\n{\nDict{String,Int64\n}\n}\n \n;\n \nblast_results\n=\n[\nFake Label\n]\n,\n \ncombo_classification\n::\nBool\n=\nfalse\n)\n\n\n\n\n\n\nClassifies an input sequence given a phylogentic tree.\n\n\nArguments\n\n\n\n\nsequence::String\n: sequence to count matches.\n\n\ntree::Node\n: the tree represented as a Node.\n\n\nCA_weights::Dict{String,Int64}\n: weights to use for CA counts.\n\n\nall_CA_weights::Dict{Int64,Dict{String,Int64}}\n: all sets of weights to use for CA counts.\n\n\noccurrence_weighting::Bool\n: whether to use occurrence weighting during counting.\n\n\ndepth::Int64\n: current depth of the tree.\n\n\ntiebreaker::Vector{Dict{String,Int64}}\n: tiebreaking procedures to use.\n\n\nblast_results=[\"Fake Label\"]\n: list of blast results.\n\n\ncombo_classification::Bool=false\n: whether to use both Blast and CAOS for classification.\n\n\n\n\nsource\n\n\n#\n\n\nCAOS.convert_to_struct\n \n \nMethod\n.\n\n\nconvert_to_struct(tree_dict::Dict{String,Any}, tree_obj::Node)\n\n\n\n\n\nTakes a tree loaded from json and convert it back to a proper internal representation.\n\n\nArguments\n\n\n\n\ntree_dict::Dict{String,Any}\n: tree as a dictionary after being read from json.\n\n\ntree_obj::Node\n: the tree (Node).\n\n\n\n\nsource\n\n\n#\n\n\nCAOS.downsample_taxa\n \n \nMethod\n.\n\n\ndownsample_taxa(taxa::Array{String}, perc_keep::Float64)\n\n\n\n\n\nDownsamples taxa by a certain percentage.\n\n\nArguments\n\n\n\n\ntaxa::Array{String}\n: list of taxa.\n\n\nperc_keep::Float64\n: percentage of taxa to keep.\n\n\n\n\nsource\n\n\n#\n\n\nCAOS.get_adjusted_start\n \n \nMethod\n.\n\n\nget_adjusted_start(original_start::Int, subject::String)\n\n\n\n\n\nAdjusts the start of the matched subject based on its blanks.\n\n\nArguments\n\n\n\n\noriginal_start::Int\n: the index of the original starting position.\n\n\nsubject::String\n: the matched subject.\n\n\n\n\nsource\n\n\n#\n\n\nCAOS.get_all_neighbors\n \n \nMethod\n.\n\n\nget_all_neighbors(tree::Node, character_labels::Dict{String,String}, taxa_label::String)\n\n\n\n\n\nTakes a tree (Node) and a taxa label and finds all the neighbors (including duplicates).\n\n\nArguments\n\n\n\n\ntree::Node\n: the tree represented as a Node.\n\n\ncharacter_labels::Dict{String,String}\n: character label mappings.\n\n\ntaxa_label::String\n: taxa label.\n\n\n\n\nsource\n\n\n#\n\n\nCAOS.get_best_hit\n \n \nMethod\n.\n\n\nget_best_hit(results::Array{BioTools.BLAST.BLASTResult,1}, query::String,\ncharacter_labels::Dict{String,String},  character_labels_no_gaps::Dict{String,String})\n\n\n\n\n\nGets the hit from blastn that has the most sequence coverage with no gaps compared to the query sequence.\n\n\nArguments\n\n\n\n\nresults::Array{BioTools.BLAST.BLASTResult,1}\n: blastn results.\n\n\nquery::String\n: the query that is having blanks added to it.\n\n\ncharacter_labels::Dict{String,String}\n: a mapping of the character labels to the corresponding sequences.\n\n\ncharacter_labels_no_gaps::Dict{String,String}\n: character labels with gaps removed from sequences.\n\n\n\n\nsource\n\n\n#\n\n\nCAOS.get_cPu_and_cPr\n \n \nMethod\n.\n\n\nget_cPu_and_cPr(nodes::Array{Dict{String,Any}}, node_num::Int64, taxa_labels::Dict{String,String},\ncharacter_labels::Dict{String,String}, sPu::Array{Dict{String,Any}}, sPr::Array{Dict{String,Any}})\n\n\n\n\n\nGets all the cPu and cPr for the entire character sequence at a specific node (does not support nucleotide options).\n\n\nArguments\n\n\n\n\nnodes::Array{Dict{String,Any}}\n: list of nodes.\n\n\nnode_num::Int64\n: current node index.\n\n\ntaxa_labels::Dict{String,String}\n: a mapping of the taxa labels to the character labels.\n\n\ncharacter_labels::Dict{String,String}\n: a mapping of the character labels to the corresponding sequences.\n\n\nsPu::Array{Dict{String,Any}}\n: list of simple pure rules.\n\n\nsPr::Array{Dict{String,Any}}\n: list of simple private rules.\n\n\n\n\nsource\n\n\n#\n\n\nCAOS.get_descendents\n \n \nMethod\n.\n\n\nget_descendents(tree::Node)\n\n\n\n\n\nGets descendents of a Node (tree or subtree).\n\n\nArguments\n\n\n\n\ntree::Node\n: the tree represented as a Node.\n\n\n\n\nsource\n\n\n#\n\n\nCAOS.get_duplicate_labels\n \n \nMethod\n.\n\n\nget_duplicate_labels(character_labels::Dict{String,String}, label::String)\n\n\n\n\n\nTakes the character labels and a specific label and finds if any other sequences are the same.\n\n\nArguments\n\n\n\n\ncharacter_labels::Dict{String,String}\n: character label mappings.\n\n\nlabel::String\n: taxa label to search for duplicates of.\n\n\n\n\nsource\n\n\n#\n\n\nCAOS.get_first_taxa_from_tree\n \n \nMethod\n.\n\n\nget_first_taxa_from_tree(tree::Node)\n\n\n\n\n\nGets the first taxa from a tree.\n\n\nArguments\n\n\n\n\ntree::Node\n: the tree represented as a Node.\n\n\n\n\nsource\n\n\n#\n\n\nCAOS.get_group_combos\n \n \nMethod\n.\n\n\nget_group_combos(group_taxa::Array{Array{String}})\n\n\n\n\n\nGets all the combinations of group vs non groups.\n\n\nArguments\n\n\n\n\ngroup_taxa::Array{Array{String}}\n: list of taxa within a group.\n\n\n\n\nsource\n\n\n#\n\n\nCAOS.get_group_taxa_at_node\n \n \nMethod\n.\n\n\nget_group_taxa_at_node(nodes::Array{Dict{String,Any}}, node_num::Int64)\n\n\n\n\n\nGets the sets of taxa for each group at a node.\n\n\nArguments\n\n\n\n\nnodes::Array{Dict{String,Any}}\n: list of nodes.\n\n\nnode_num::Int64\n: current node index.\n\n\n\n\nsource\n\n\n#\n\n\nCAOS.get_neighbors\n \n \nMethod\n.\n\n\nget_neighbors(tree::Node, taxa_label::String)\n\n\n\n\n\nTakes a tree (Node) and a taxa label and finds all the neighbors (taxa that come after from the subtree containing the input taxa).\n\n\nArguments\n\n\n\n\ntree::Node\n: the tree represented as a Node.\n\n\ntaxa_label::String\n: taxa label.\n\n\n\n\nsource\n\n\n#\n\n\nCAOS.get_next_hit\n \n \nMethod\n.\n\n\nget_next_hit(hitnames::Vector{String}, hit_idx::Int64)\n\n\n\n\n\nGets the next best hit returned from a blastn search.\n\n\nArguments\n\n\n\n\nhitnames::Vector{String}\n: a list of all blastn hitnames.\n\n\nhit_idx::Int64\n: index of the current hit.\n\n\n\n\nsource\n\n\n#\n\n\nCAOS.get_sPu_and_sPr\n \n \nMethod\n.\n\n\nget_sPu_and_sPr(nodes::Array{Dict{String,Any}}, node_num::Int64,\ntaxa_labels::Dict{String,String}, character_labels::Dict{String,String})\n\n\n\n\n\nGets all the sPu and sPr for the entire character sequence at a specific node.\n\n\nArguments\n\n\n\n\nnodes::Array{Dict{String,Any}}\n: list of nodes.\n\n\nnode_num::Int64\n: current node index.\n\n\ntaxa_labels::Dict{String,String}\n: a mapping of the taxa labels to the character labels.\n\n\ncharacter_labels::Dict{String,String}\n: a mapping of the character labels to the corresponding sequences.\n\n\n\n\nsource\n\n\n#\n\n\nCAOS.Node\n \n \nType\n.\n\n\nNode(CAs::Array{Rule,1}, taxa_label::String=\n)\n\n\n\n\n\nStruct to store a node (is recursive).\n\n\nsource\n\n\n#\n\n\nCAOS.Rule\n \n \nType\n.\n\n\nRule(idxs::Tuple{Vararg{Int}}, char_attr::Tuple{Vararg{Char}},\nis_pure::Bool, num_group::Int, num_non_group::Int, occurances::Int)\n\n\n\n\n\nStruct to store relevant information about a CA.\n\n\nsource", 
            "title": "Functions"
        }, 
        {
            "location": "/documentation/#import", 
            "text": "using CAOS", 
            "title": "Import"
        }, 
        {
            "location": "/documentation/#index", 
            "text": "CAOS.Node  CAOS.Rule  CAOS.CA_matches  CAOS.CV_classification  CAOS.add_blanks  CAOS.add_blanks_to_back  CAOS.add_blanks_to_front  CAOS.add_nodes!  CAOS.check_CV_classification  CAOS.classify_all_CV  CAOS.classify_new_sequence  CAOS.classify_sequence  CAOS.convert_to_struct  CAOS.downsample_taxa  CAOS.find_sequence  CAOS.generate_caos_rules  CAOS.get_adjusted_start  CAOS.get_all_neighbors  CAOS.get_best_hit  CAOS.get_cPu_and_cPr  CAOS.get_descendents  CAOS.get_duplicate_labels  CAOS.get_first_taxa_from_tree  CAOS.get_group_combos  CAOS.get_group_taxa_at_node  CAOS.get_max_depth  CAOS.get_neighbors  CAOS.get_next_hit  CAOS.get_nodes  CAOS.get_sPu_and_sPr  CAOS.load_tree  CAOS.parse_tree  CAOS.remove_blanks  CAOS.remove_from_tree!", 
            "title": "Index"
        }, 
        {
            "location": "/documentation/#functions", 
            "text": "#  CAOS.classify_new_sequence     Method .  classify_new_sequence ( tree :: Node ,   character_labels :: Dict { String,String } ,   taxa_labels :: Dict { String,String } ,  sequence_file_path :: String ,   output_directory :: String   ;   all_CA_weights :: Dict { Int64,  Dict{String,Int64 } } = Dict ( 1 = Dict ( sPu = 1 , sPr = 1 , cPu = 1 , cPr = 1 )),   occurrence_weighting :: Bool = false ,  tiebreaker :: Vector { Dict{String,Int64 } } = [ Dict { String , Int64 }() ] ,   combo_classification :: Bool = false )   Takes a tree (Node) and a sequence, and classifies the new sequence using the CAOS tree.  Arguments   tree::Node : the tree represented as a Node.  character_labels::Dict{String,String} : a mapping of the character labels to the corresponding sequences.  taxa_labels::Dict{String,String} : a mapping of the taxa labels to the character labels.  sequence_file_path::String : a file path to the sequence to classify.  output_directory::String : path to the output directory.  all_CA_weights::Dict{Int64,Dict{String,Int64}}=Dict(1= Dict(\"sPu\"= 1,\"sPr\"= 1,\"cPu\"= 1,\"cPr\"= 1)) : CA weights to be used.  occurrence_weighting::Bool=false : whether to use occurence weighting in classification.  tiebreaker::Vector{Dict{String,Int64}}=[Dict{String,Int64}()] : tiebreaker to be used in classification.  combo_classification::Bool=false : whether to use a combo of Blast and CAOS for classification.   source  #  CAOS.find_sequence     Method .  find_sequence(tree::Node, taxa_label::String)  Takes a tree (Node) and a taxa label and finds the subtree containing that sequence.  Arguments   tree::Node : the tree represented as a Node.  taxa_label::String : taxa label.   source  #  CAOS.generate_caos_rules     Method .  generate_caos_rules(tree_file_path::String, output_directory::String)  Takes a Nexus file and generates all the CAOS rules for the tree.  Arguments   tree_file_path::String : path to the Nexus file.  output_directory::String : path to the output directory.   source  #  CAOS.get_max_depth     Method .  get_max_depth(tree::Node, depth::Int64)  Takes a tree (Node) and gets the maximum depth.  Arguments   tree::Node : the tree represented as a Node.  depth::Int64 : current depth.   source  #  CAOS.get_nodes     Method .  get_nodes ( tree :: String   ;   taxa_to_remove :: Union { Array{String,1 } , Bool } = false )   Takes a tree in Newick format, returns an internal representation of the tree.  Arguments   tree::String : the tree in Newick format.  taxa_to_remove::Union{Array{String,1},Bool}=false : the taxa that will be removed (if applicable).   source  #  CAOS.load_tree     Method .  load_tree(directory::String)  Loads a CAOS tree from file.  Arguments   directory::String : path to directory where tree exists.   source  #  CAOS.parse_tree     Method .  parse_tree ( file_path :: String ;   taxa_to_remove :: Union { Array{String,1 } , Bool } = false )   Takes a Nexus file for a tree, returns an internal representation of that tree (and other relevant information).  Arguments   file_path::String : file path to the Nexus file.  taxa_to_remove::Union{Array{String,1},Bool}=false : the taxa that will be removed (if applicable).   source  #  CAOS.remove_blanks     Method .  remove_blanks ( char_label_dict :: Dict { String,String }   ;   change_to_N :: Bool = false )   Changes all blanks to N's in character sequences.  Arguments   char_label_dict::Dict{String,String} : character label mappings.  change_to_N::Bool=false : whether to change to N or just remove.   source  #  CAOS.remove_from_tree!     Method .  remove_from_tree!(tree_tokens::Vector{String}, taxa_to_remove::Union{Array{String,1},Bool})  Takes a tree in Newick format, removes a specific taxa from the tree.  Arguments   tree_tokens::Vector{String} : the tree in Newick format, tokenized.  taxa_to_remove::Union{Array{String,1},Bool} : the taxa that will be removed.   source  #  CAOS.CA_matches     Method .  CA_matches(sequence::String, CAs::Vector{Rule}, CA_weights::Dict{String,Int64}, occurrence_weighting::Bool)  Counts the number of CA's matched by a sequence (only support for simple rules).  Arguments   sequence::String : sequence to count matches.  CAs::Vector{Rule} : list of all CA's.  CA_weights::Dict{String,Int64} : weights to use for CA counts.  occurrence_weighting::Bool : whether to use occurrence weighting during counting.   source  #  CAOS.CV_classification     Method .  CV_classification ( taxa_label :: String ,   character_labels :: Dict { String,String } ,  gene :: String ,   percent_test :: String ,   all_CA_weights :: Dict { Int,Dict{String,Int64 } } ,  occurrence_weighting :: Bool ,   tiebreaker :: Vector { Dict{String,Int64 } } ;   combo_classification :: Bool = false )   Gets the classification for a LOOCV tree.  Arguments   taxa_label::String : taxa to classify.  character_labels::Dict{String,String} : a mapping of the character labels to the corresponding sequences.  gene::String : gene which is being classified.  percent_test::String : percent we are testing on.  all_CA_weights::Dict{Int64,Dict{String,Int64}} : all sets of weights to use for CA counts.  occurrence_weighting::Bool : whether to use occurrence weighting during counting.  tiebreaker::Vector{Dict{String,Int64}} : tiebreaking procedures to use.  combo_classification::Bool=false : whether to use both Blast and CAOS for classification.   source  #  CAOS.add_blanks     Method .  add_blanks ( query_path :: String ,   db_path :: String ,   character_labels :: Dict { String,String } ,  character_labels_no_gaps :: Dict { String,String }   ;   return_blast :: Bool = false )   Adds blanks to an input sequence given a database.  Arguments   query_path::String : path to the query file.  db_path::String : path to the blast database.  character_labels::Dict{String,String} : a mapping of the character labels to the corresponding sequences.  character_labels_no_gaps::Dict{String,String} : character labels with gaps removed from sequences.  return_blast::Bool=false : whether to return blast results.   source  #  CAOS.add_blanks_to_back     Method .  add_blanks_to_back(subject::String, query::String, new_seq::String,\nsubj_len::Int64, query_len::Int64, subj_non_blanks::Int64,\nhitnames::Vector{String}, hit_idx::Int64, character_labels::Dict{String,String})  Adds blanks to the back of a sequence from a blast match.  Arguments   subject::String : the subject the query is being matched to.  query::String : the query that is having blanks added to it.  new_seq::String : the new sequence (query with added blanks).  subj_len::Int64 : length of the subject.  query_len::Int64 : length of the query.  subj_non_blanks::Int64 : number of non blanks in the subject.  hitnames::Vector{String} : list of blast hits.  hit_idx::Int64 : index of the current blast hit.  character_labels::Dict{String,String} : a mapping of the character labels to the corresponding sequences.   source  #  CAOS.add_blanks_to_front     Method .  add_blanks_to_front(subject::String, query::String, new_seq::String,\nsubj_len::Int64, query_len::Int64, subj_non_blanks::Int64,\nhitnames::Vector{String}, hit_idx::Int64, character_labels::Dict{String,String})  Adds blanks to the front of a sequence from a blast match.  Arguments   subject::String : the subject the query is being matched to.  query::String : the query that is having blanks added to it.  new_seq::String : the new sequence (query with added blanks).  subj_len::Int64 : length of the subject.  query_len::Int64 : length of the query.  subj_non_blanks::Int64 : number of non blanks in the subject.  hitnames::Vector{String} : list of blast hits.  hit_idx::Int64 : index of the current blast hit.  character_labels::Dict{String,String} : a mapping of the character labels to the corresponding sequences.   source  #  CAOS.add_nodes!     Method .  add_nodes !( tree :: Node , sPu :: Array { Dict{String,Any } } , sPr :: Array { Dict{String,Any } } ,  cPu :: Array { Dict{String,Any } } , cPr :: Array { Dict{String,Any } } , taxa_labels :: Dict { String,String } ,  character_labels :: Dict { String,String } , nodes :: Array { Dict{String,Any } } , node_num :: Int64 ; complex :: Bool = true )   Takes a tree (Node), adds all the CA's from the entire tree into the internal representation.  Arguments   tree::Node : the tree represented as a Node.  sPu::Array{Dict{String,Any}} : an array of simple pure rules.  sPr::Array{Dict{String,Any}} : an array of simple private rules.  cPu::Array{Dict{String,Any}} : an array of complex pure rules.  cPr::Array{Dict{String,Any}} : an array of complex private rules.  taxa_labels::Dict{String,String} : a mapping of the taxa labels to the character labels.  character_labels::Dict{String,String} : a mapping of the character labels to the corresponding sequences.  nodes::Array{Dict{String,Any}} : an array of nodes.  node_num::Int64 : the current node number.  complex::Bool=true : indicates whether complex rules should be calculated   source  #  CAOS.check_CV_classification     Method .  check_CV_classification(taxa_label::String, character_labels::Dict{String,String},\ntaxa_labels::Dict{String,String}, classification::Any, gene::String)  Checks if the classification from a LOOCV tree is correct.  Arguments   taxa_label::String : taxa to classify.  character_labels::Dict{String,String} : a mapping of the character labels to the corresponding sequences.  taxa_labels::Dict{String,String} : a mapping of the taxa labels to the character labels.  classification::Any : the classification to check.  gene::String : gene which is being classified.   source  #  CAOS.classify_all_CV     Method .  classify_all_CV ( character_labels :: Dict { String,String } ,   taxa_labels :: Dict { String,String } ,  gene :: String ,   percent_test :: String   ;   blast_only :: Bool = false ,  all_CA_weights :: Dict { Int64,Dict{String,Int64 } } = Dict ( 1 = Dict ( sPu = 1 , sPr = 1 , cPu = 1 , cPr = 1 )),  occurrence_weighting :: Bool = false ,   tiebreaker :: Vector { Dict{String,Int64 } } = [ Dict { String , Int64 }() ] ,  downsample :: Bool = false ,   combo_classification :: Bool = false )   Classifies all sequences using CAOS and LOOCV.  Arguments   character_labels::Dict{String,String} : a mapping of the character labels to the corresponding sequences.  taxa_labels::Dict{String,String} : a mapping of the taxa labels to the character labels.  gene::String : gene which is being classified.  percent_test::String : percent we are testing on.  blast_only::Bool=false : whether we are only using Blast to classify.  all_CA_weights::Dict{Int64,Dict{String,Int64}}=Dict(1= Dict(\"sPu\"= 1,\"sPr\"= 1,\"cPu\"= 1,\"cPr\"= 1)) : CA weights to be used.  occurrence_weighting::Bool=false : whether to use occurence weighting in classification.  tiebreaker::Vector{Dict{String,Int64}}=[Dict{String,Int64}()] : tiebreaker to be used in classification.  downsample::Bool=false : whether we are using downsampling.  combo_classification::Bool=false : whether to use a combo of Blast and CAOS for classification.   source  #  CAOS.classify_sequence     Method .  classify_sequence ( sequence :: String ,   tree :: Node ,   CA_weights :: Dict { String,Int64 } ,  all_CA_weights :: Dict { Int64,Dict{String,Int64 } } ,   occurrence_weighting :: Bool ,  depth :: Int64 ,   tiebreaker :: Vector { Dict{String,Int64 } }   ;   blast_results = [ Fake Label ] ,   combo_classification :: Bool = false )   Classifies an input sequence given a phylogentic tree.  Arguments   sequence::String : sequence to count matches.  tree::Node : the tree represented as a Node.  CA_weights::Dict{String,Int64} : weights to use for CA counts.  all_CA_weights::Dict{Int64,Dict{String,Int64}} : all sets of weights to use for CA counts.  occurrence_weighting::Bool : whether to use occurrence weighting during counting.  depth::Int64 : current depth of the tree.  tiebreaker::Vector{Dict{String,Int64}} : tiebreaking procedures to use.  blast_results=[\"Fake Label\"] : list of blast results.  combo_classification::Bool=false : whether to use both Blast and CAOS for classification.   source  #  CAOS.convert_to_struct     Method .  convert_to_struct(tree_dict::Dict{String,Any}, tree_obj::Node)  Takes a tree loaded from json and convert it back to a proper internal representation.  Arguments   tree_dict::Dict{String,Any} : tree as a dictionary after being read from json.  tree_obj::Node : the tree (Node).   source  #  CAOS.downsample_taxa     Method .  downsample_taxa(taxa::Array{String}, perc_keep::Float64)  Downsamples taxa by a certain percentage.  Arguments   taxa::Array{String} : list of taxa.  perc_keep::Float64 : percentage of taxa to keep.   source  #  CAOS.get_adjusted_start     Method .  get_adjusted_start(original_start::Int, subject::String)  Adjusts the start of the matched subject based on its blanks.  Arguments   original_start::Int : the index of the original starting position.  subject::String : the matched subject.   source  #  CAOS.get_all_neighbors     Method .  get_all_neighbors(tree::Node, character_labels::Dict{String,String}, taxa_label::String)  Takes a tree (Node) and a taxa label and finds all the neighbors (including duplicates).  Arguments   tree::Node : the tree represented as a Node.  character_labels::Dict{String,String} : character label mappings.  taxa_label::String : taxa label.   source  #  CAOS.get_best_hit     Method .  get_best_hit(results::Array{BioTools.BLAST.BLASTResult,1}, query::String,\ncharacter_labels::Dict{String,String},  character_labels_no_gaps::Dict{String,String})  Gets the hit from blastn that has the most sequence coverage with no gaps compared to the query sequence.  Arguments   results::Array{BioTools.BLAST.BLASTResult,1} : blastn results.  query::String : the query that is having blanks added to it.  character_labels::Dict{String,String} : a mapping of the character labels to the corresponding sequences.  character_labels_no_gaps::Dict{String,String} : character labels with gaps removed from sequences.   source  #  CAOS.get_cPu_and_cPr     Method .  get_cPu_and_cPr(nodes::Array{Dict{String,Any}}, node_num::Int64, taxa_labels::Dict{String,String},\ncharacter_labels::Dict{String,String}, sPu::Array{Dict{String,Any}}, sPr::Array{Dict{String,Any}})  Gets all the cPu and cPr for the entire character sequence at a specific node (does not support nucleotide options).  Arguments   nodes::Array{Dict{String,Any}} : list of nodes.  node_num::Int64 : current node index.  taxa_labels::Dict{String,String} : a mapping of the taxa labels to the character labels.  character_labels::Dict{String,String} : a mapping of the character labels to the corresponding sequences.  sPu::Array{Dict{String,Any}} : list of simple pure rules.  sPr::Array{Dict{String,Any}} : list of simple private rules.   source  #  CAOS.get_descendents     Method .  get_descendents(tree::Node)  Gets descendents of a Node (tree or subtree).  Arguments   tree::Node : the tree represented as a Node.   source  #  CAOS.get_duplicate_labels     Method .  get_duplicate_labels(character_labels::Dict{String,String}, label::String)  Takes the character labels and a specific label and finds if any other sequences are the same.  Arguments   character_labels::Dict{String,String} : character label mappings.  label::String : taxa label to search for duplicates of.   source  #  CAOS.get_first_taxa_from_tree     Method .  get_first_taxa_from_tree(tree::Node)  Gets the first taxa from a tree.  Arguments   tree::Node : the tree represented as a Node.   source  #  CAOS.get_group_combos     Method .  get_group_combos(group_taxa::Array{Array{String}})  Gets all the combinations of group vs non groups.  Arguments   group_taxa::Array{Array{String}} : list of taxa within a group.   source  #  CAOS.get_group_taxa_at_node     Method .  get_group_taxa_at_node(nodes::Array{Dict{String,Any}}, node_num::Int64)  Gets the sets of taxa for each group at a node.  Arguments   nodes::Array{Dict{String,Any}} : list of nodes.  node_num::Int64 : current node index.   source  #  CAOS.get_neighbors     Method .  get_neighbors(tree::Node, taxa_label::String)  Takes a tree (Node) and a taxa label and finds all the neighbors (taxa that come after from the subtree containing the input taxa).  Arguments   tree::Node : the tree represented as a Node.  taxa_label::String : taxa label.   source  #  CAOS.get_next_hit     Method .  get_next_hit(hitnames::Vector{String}, hit_idx::Int64)  Gets the next best hit returned from a blastn search.  Arguments   hitnames::Vector{String} : a list of all blastn hitnames.  hit_idx::Int64 : index of the current hit.   source  #  CAOS.get_sPu_and_sPr     Method .  get_sPu_and_sPr(nodes::Array{Dict{String,Any}}, node_num::Int64,\ntaxa_labels::Dict{String,String}, character_labels::Dict{String,String})  Gets all the sPu and sPr for the entire character sequence at a specific node.  Arguments   nodes::Array{Dict{String,Any}} : list of nodes.  node_num::Int64 : current node index.  taxa_labels::Dict{String,String} : a mapping of the taxa labels to the character labels.  character_labels::Dict{String,String} : a mapping of the character labels to the corresponding sequences.   source  #  CAOS.Node     Type .  Node(CAs::Array{Rule,1}, taxa_label::String= )  Struct to store a node (is recursive).  source  #  CAOS.Rule     Type .  Rule(idxs::Tuple{Vararg{Int}}, char_attr::Tuple{Vararg{Char}},\nis_pure::Bool, num_group::Int, num_non_group::Int, occurances::Int)  Struct to store relevant information about a CA.  source", 
            "title": "Functions"
        }
    ]
}